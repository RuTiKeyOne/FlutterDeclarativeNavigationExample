// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'route_path.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$RoutePath {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() error,
    required TResult Function() signin,
    required TResult Function() main,
    required TResult Function() splash,
    required TResult Function() basket,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? error,
    TResult? Function()? signin,
    TResult? Function()? main,
    TResult? Function()? splash,
    TResult? Function()? basket,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? error,
    TResult Function()? signin,
    TResult Function()? main,
    TResult Function()? splash,
    TResult Function()? basket,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RouteErrorPath value) error,
    required TResult Function(RouteSigninPath value) signin,
    required TResult Function(RouteMainPath value) main,
    required TResult Function(RouteSplashPath value) splash,
    required TResult Function(RouteBasketPath value) basket,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RouteErrorPath value)? error,
    TResult? Function(RouteSigninPath value)? signin,
    TResult? Function(RouteMainPath value)? main,
    TResult? Function(RouteSplashPath value)? splash,
    TResult? Function(RouteBasketPath value)? basket,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RouteErrorPath value)? error,
    TResult Function(RouteSigninPath value)? signin,
    TResult Function(RouteMainPath value)? main,
    TResult Function(RouteSplashPath value)? splash,
    TResult Function(RouteBasketPath value)? basket,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RoutePathCopyWith<$Res> {
  factory $RoutePathCopyWith(RoutePath value, $Res Function(RoutePath) then) =
      _$RoutePathCopyWithImpl<$Res, RoutePath>;
}

/// @nodoc
class _$RoutePathCopyWithImpl<$Res, $Val extends RoutePath>
    implements $RoutePathCopyWith<$Res> {
  _$RoutePathCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$RouteErrorPathCopyWith<$Res> {
  factory _$$RouteErrorPathCopyWith(
          _$RouteErrorPath value, $Res Function(_$RouteErrorPath) then) =
      __$$RouteErrorPathCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RouteErrorPathCopyWithImpl<$Res>
    extends _$RoutePathCopyWithImpl<$Res, _$RouteErrorPath>
    implements _$$RouteErrorPathCopyWith<$Res> {
  __$$RouteErrorPathCopyWithImpl(
      _$RouteErrorPath _value, $Res Function(_$RouteErrorPath) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RouteErrorPath implements RouteErrorPath {
  const _$RouteErrorPath();

  @override
  String toString() {
    return 'RoutePath.error()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RouteErrorPath);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() error,
    required TResult Function() signin,
    required TResult Function() main,
    required TResult Function() splash,
    required TResult Function() basket,
  }) {
    return error();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? error,
    TResult? Function()? signin,
    TResult? Function()? main,
    TResult? Function()? splash,
    TResult? Function()? basket,
  }) {
    return error?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? error,
    TResult Function()? signin,
    TResult Function()? main,
    TResult Function()? splash,
    TResult Function()? basket,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RouteErrorPath value) error,
    required TResult Function(RouteSigninPath value) signin,
    required TResult Function(RouteMainPath value) main,
    required TResult Function(RouteSplashPath value) splash,
    required TResult Function(RouteBasketPath value) basket,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RouteErrorPath value)? error,
    TResult? Function(RouteSigninPath value)? signin,
    TResult? Function(RouteMainPath value)? main,
    TResult? Function(RouteSplashPath value)? splash,
    TResult? Function(RouteBasketPath value)? basket,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RouteErrorPath value)? error,
    TResult Function(RouteSigninPath value)? signin,
    TResult Function(RouteMainPath value)? main,
    TResult Function(RouteSplashPath value)? splash,
    TResult Function(RouteBasketPath value)? basket,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class RouteErrorPath implements RoutePath {
  const factory RouteErrorPath() = _$RouteErrorPath;
}

/// @nodoc
abstract class _$$RouteSigninPathCopyWith<$Res> {
  factory _$$RouteSigninPathCopyWith(
          _$RouteSigninPath value, $Res Function(_$RouteSigninPath) then) =
      __$$RouteSigninPathCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RouteSigninPathCopyWithImpl<$Res>
    extends _$RoutePathCopyWithImpl<$Res, _$RouteSigninPath>
    implements _$$RouteSigninPathCopyWith<$Res> {
  __$$RouteSigninPathCopyWithImpl(
      _$RouteSigninPath _value, $Res Function(_$RouteSigninPath) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RouteSigninPath implements RouteSigninPath {
  const _$RouteSigninPath();

  @override
  String toString() {
    return 'RoutePath.signin()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RouteSigninPath);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() error,
    required TResult Function() signin,
    required TResult Function() main,
    required TResult Function() splash,
    required TResult Function() basket,
  }) {
    return signin();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? error,
    TResult? Function()? signin,
    TResult? Function()? main,
    TResult? Function()? splash,
    TResult? Function()? basket,
  }) {
    return signin?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? error,
    TResult Function()? signin,
    TResult Function()? main,
    TResult Function()? splash,
    TResult Function()? basket,
    required TResult orElse(),
  }) {
    if (signin != null) {
      return signin();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RouteErrorPath value) error,
    required TResult Function(RouteSigninPath value) signin,
    required TResult Function(RouteMainPath value) main,
    required TResult Function(RouteSplashPath value) splash,
    required TResult Function(RouteBasketPath value) basket,
  }) {
    return signin(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RouteErrorPath value)? error,
    TResult? Function(RouteSigninPath value)? signin,
    TResult? Function(RouteMainPath value)? main,
    TResult? Function(RouteSplashPath value)? splash,
    TResult? Function(RouteBasketPath value)? basket,
  }) {
    return signin?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RouteErrorPath value)? error,
    TResult Function(RouteSigninPath value)? signin,
    TResult Function(RouteMainPath value)? main,
    TResult Function(RouteSplashPath value)? splash,
    TResult Function(RouteBasketPath value)? basket,
    required TResult orElse(),
  }) {
    if (signin != null) {
      return signin(this);
    }
    return orElse();
  }
}

abstract class RouteSigninPath implements RoutePath {
  const factory RouteSigninPath() = _$RouteSigninPath;
}

/// @nodoc
abstract class _$$RouteMainPathCopyWith<$Res> {
  factory _$$RouteMainPathCopyWith(
          _$RouteMainPath value, $Res Function(_$RouteMainPath) then) =
      __$$RouteMainPathCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RouteMainPathCopyWithImpl<$Res>
    extends _$RoutePathCopyWithImpl<$Res, _$RouteMainPath>
    implements _$$RouteMainPathCopyWith<$Res> {
  __$$RouteMainPathCopyWithImpl(
      _$RouteMainPath _value, $Res Function(_$RouteMainPath) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RouteMainPath implements RouteMainPath {
  const _$RouteMainPath();

  @override
  String toString() {
    return 'RoutePath.main()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RouteMainPath);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() error,
    required TResult Function() signin,
    required TResult Function() main,
    required TResult Function() splash,
    required TResult Function() basket,
  }) {
    return main();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? error,
    TResult? Function()? signin,
    TResult? Function()? main,
    TResult? Function()? splash,
    TResult? Function()? basket,
  }) {
    return main?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? error,
    TResult Function()? signin,
    TResult Function()? main,
    TResult Function()? splash,
    TResult Function()? basket,
    required TResult orElse(),
  }) {
    if (main != null) {
      return main();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RouteErrorPath value) error,
    required TResult Function(RouteSigninPath value) signin,
    required TResult Function(RouteMainPath value) main,
    required TResult Function(RouteSplashPath value) splash,
    required TResult Function(RouteBasketPath value) basket,
  }) {
    return main(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RouteErrorPath value)? error,
    TResult? Function(RouteSigninPath value)? signin,
    TResult? Function(RouteMainPath value)? main,
    TResult? Function(RouteSplashPath value)? splash,
    TResult? Function(RouteBasketPath value)? basket,
  }) {
    return main?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RouteErrorPath value)? error,
    TResult Function(RouteSigninPath value)? signin,
    TResult Function(RouteMainPath value)? main,
    TResult Function(RouteSplashPath value)? splash,
    TResult Function(RouteBasketPath value)? basket,
    required TResult orElse(),
  }) {
    if (main != null) {
      return main(this);
    }
    return orElse();
  }
}

abstract class RouteMainPath implements RoutePath {
  const factory RouteMainPath() = _$RouteMainPath;
}

/// @nodoc
abstract class _$$RouteSplashPathCopyWith<$Res> {
  factory _$$RouteSplashPathCopyWith(
          _$RouteSplashPath value, $Res Function(_$RouteSplashPath) then) =
      __$$RouteSplashPathCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RouteSplashPathCopyWithImpl<$Res>
    extends _$RoutePathCopyWithImpl<$Res, _$RouteSplashPath>
    implements _$$RouteSplashPathCopyWith<$Res> {
  __$$RouteSplashPathCopyWithImpl(
      _$RouteSplashPath _value, $Res Function(_$RouteSplashPath) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RouteSplashPath implements RouteSplashPath {
  const _$RouteSplashPath();

  @override
  String toString() {
    return 'RoutePath.splash()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RouteSplashPath);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() error,
    required TResult Function() signin,
    required TResult Function() main,
    required TResult Function() splash,
    required TResult Function() basket,
  }) {
    return splash();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? error,
    TResult? Function()? signin,
    TResult? Function()? main,
    TResult? Function()? splash,
    TResult? Function()? basket,
  }) {
    return splash?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? error,
    TResult Function()? signin,
    TResult Function()? main,
    TResult Function()? splash,
    TResult Function()? basket,
    required TResult orElse(),
  }) {
    if (splash != null) {
      return splash();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RouteErrorPath value) error,
    required TResult Function(RouteSigninPath value) signin,
    required TResult Function(RouteMainPath value) main,
    required TResult Function(RouteSplashPath value) splash,
    required TResult Function(RouteBasketPath value) basket,
  }) {
    return splash(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RouteErrorPath value)? error,
    TResult? Function(RouteSigninPath value)? signin,
    TResult? Function(RouteMainPath value)? main,
    TResult? Function(RouteSplashPath value)? splash,
    TResult? Function(RouteBasketPath value)? basket,
  }) {
    return splash?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RouteErrorPath value)? error,
    TResult Function(RouteSigninPath value)? signin,
    TResult Function(RouteMainPath value)? main,
    TResult Function(RouteSplashPath value)? splash,
    TResult Function(RouteBasketPath value)? basket,
    required TResult orElse(),
  }) {
    if (splash != null) {
      return splash(this);
    }
    return orElse();
  }
}

abstract class RouteSplashPath implements RoutePath {
  const factory RouteSplashPath() = _$RouteSplashPath;
}

/// @nodoc
abstract class _$$RouteBasketPathCopyWith<$Res> {
  factory _$$RouteBasketPathCopyWith(
          _$RouteBasketPath value, $Res Function(_$RouteBasketPath) then) =
      __$$RouteBasketPathCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RouteBasketPathCopyWithImpl<$Res>
    extends _$RoutePathCopyWithImpl<$Res, _$RouteBasketPath>
    implements _$$RouteBasketPathCopyWith<$Res> {
  __$$RouteBasketPathCopyWithImpl(
      _$RouteBasketPath _value, $Res Function(_$RouteBasketPath) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RouteBasketPath implements RouteBasketPath {
  const _$RouteBasketPath();

  @override
  String toString() {
    return 'RoutePath.basket()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RouteBasketPath);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() error,
    required TResult Function() signin,
    required TResult Function() main,
    required TResult Function() splash,
    required TResult Function() basket,
  }) {
    return basket();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? error,
    TResult? Function()? signin,
    TResult? Function()? main,
    TResult? Function()? splash,
    TResult? Function()? basket,
  }) {
    return basket?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? error,
    TResult Function()? signin,
    TResult Function()? main,
    TResult Function()? splash,
    TResult Function()? basket,
    required TResult orElse(),
  }) {
    if (basket != null) {
      return basket();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RouteErrorPath value) error,
    required TResult Function(RouteSigninPath value) signin,
    required TResult Function(RouteMainPath value) main,
    required TResult Function(RouteSplashPath value) splash,
    required TResult Function(RouteBasketPath value) basket,
  }) {
    return basket(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RouteErrorPath value)? error,
    TResult? Function(RouteSigninPath value)? signin,
    TResult? Function(RouteMainPath value)? main,
    TResult? Function(RouteSplashPath value)? splash,
    TResult? Function(RouteBasketPath value)? basket,
  }) {
    return basket?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RouteErrorPath value)? error,
    TResult Function(RouteSigninPath value)? signin,
    TResult Function(RouteMainPath value)? main,
    TResult Function(RouteSplashPath value)? splash,
    TResult Function(RouteBasketPath value)? basket,
    required TResult orElse(),
  }) {
    if (basket != null) {
      return basket(this);
    }
    return orElse();
  }
}

abstract class RouteBasketPath implements RoutePath {
  const factory RouteBasketPath() = _$RouteBasketPath;
}
